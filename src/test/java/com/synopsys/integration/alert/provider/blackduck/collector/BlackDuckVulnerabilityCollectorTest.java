package com.synopsys.integration.alert.provider.blackduck.collector;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertTrue;

import java.io.File;
import java.io.IOException;
import java.nio.charset.Charset;
import java.time.Instant;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.function.Predicate;
import java.util.stream.Collectors;

import org.apache.commons.io.FileUtils;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.slf4j.Logger;
import org.springframework.core.io.ClassPathResource;

import com.google.gson.Gson;
import com.synopsys.integration.alert.TestConstants;
import com.synopsys.integration.alert.common.enumeration.FormatType;
import com.synopsys.integration.alert.common.message.model.ComponentItem;
import com.synopsys.integration.alert.common.message.model.LinkableItem;
import com.synopsys.integration.alert.common.message.model.MessageContentGroup;
import com.synopsys.integration.alert.common.message.model.ProviderMessageContent;
import com.synopsys.integration.alert.common.workflow.filter.field.JsonExtractor;
import com.synopsys.integration.alert.common.workflow.processor.DefaultMessageContentProcessor;
import com.synopsys.integration.alert.common.workflow.processor.DigestMessageContentProcessor;
import com.synopsys.integration.alert.common.workflow.processor.MessageContentCollapser;
import com.synopsys.integration.alert.common.workflow.processor.MessageContentProcessor;
import com.synopsys.integration.alert.database.notification.NotificationContent;
import com.synopsys.integration.alert.provider.blackduck.BlackDuckProperties;
import com.synopsys.integration.alert.provider.blackduck.BlackDuckProvider;
import com.synopsys.integration.alert.provider.blackduck.collector.item.VulnerabilitySeverity;
import com.synopsys.integration.alert.provider.blackduck.descriptor.BlackDuckContent;
import com.synopsys.integration.blackduck.api.generated.enumeration.NotificationType;
import com.synopsys.integration.blackduck.api.generated.view.VulnerabilityView;
import com.synopsys.integration.blackduck.rest.BlackDuckHttpClient;
import com.synopsys.integration.blackduck.service.BlackDuckService;
import com.synopsys.integration.blackduck.service.BlackDuckServicesFactory;
import com.synopsys.integration.blackduck.service.bucket.BlackDuckBucketService;
import com.synopsys.integration.exception.IntegrationException;
import com.synopsys.integration.log.Slf4jIntLogger;

public class BlackDuckVulnerabilityCollectorTest {
    public static final String HIGH_VULNERABILITY = VulnerabilitySeverity.HIGH.toString();
    public static final String MEDIUM_VULNERABILITY = VulnerabilitySeverity.MEDIUM.toString();
    public static final String LOW_VULNERABILITY = VulnerabilitySeverity.LOW.toString();
    public static final String UNKNOWN_VULNERABILITY = VulnerabilitySeverity.UNKNOWN.toString();
    public static final String VULNERABILITY_URL_CVE_1 = "https://a-hub-server.blackduck.com/api/vulnerabilities/CVE-2018-0001";
    public static final String VULNERABILITY_URL_CVE_2 = "https://a-hub-server.blackduck.com/api/vulnerabilities/CVE-2018-0002";
    public static final String VULNERABILITY_URL_CVE_3 = "https://a-hub-server.blackduck.com/api/vulnerabilities/CVE-2018-0003";
    public static final String VULNERABILITY_URL_CVE_4 = "https://a-hub-server.blackduck.com/api/vulnerabilities/CVE-2018-0004";
    public static final String VULNERABILITY_URL_CVE_5 = "https://a-hub-server.blackduck.com/api/vulnerabilities/CVE-2018-0005";
    public static final String VULNERABILITY_URL_CVE_6 = "https://a-hub-server.blackduck.com/api/vulnerabilities/CVE-2018-0006";
    public static final String VULNERABILITY_URL_CVE_7 = "https://a-hub-server.blackduck.com/api/vulnerabilities/CVE-2018-0007";
    public static final String VULNERABILITY_URL_CVE_8 = "https://a-hub-server.blackduck.com/api/vulnerabilities/CVE-2018-0008";
    public static final String VULNERABILITY_URL_CVE_9 = "https://a-hub-server.blackduck.com/api/vulnerabilities/CVE-2018-0009";
    public static final String VULNERABILITY_URL_CVE_10 = "https://a-hub-server.blackduck.com/api/vulnerabilities/CVE-2018-0010";
    public static final String VULNERABILITY_URL_CVE_11 = "https://a-hub-server.blackduck.com/api/vulnerabilities/CVE-2018-0011";
    public static final String VULNERABILITY_URL_CVE_12 = "https://a-hub-server.blackduck.com/api/vulnerabilities/CVE-2018-0012";
    public static final String VULNERABILITY_URL_CVE_13 = "https://a-hub-server.blackduck.com/api/vulnerabilities/CVE-2018-0013";
    public static final String VULNERABILITY_URL_BDSA_4 = "https://a-hub-server.blackduck.com/api/vulnerabilities/BDSA-2018-0004";
    private final List<MessageContentProcessor> messageContentProcessorList = Arrays.asList(new DefaultMessageContentProcessor(), new DigestMessageContentProcessor(new DefaultMessageContentProcessor(), new MessageContentCollapser()));
    private final Gson gson = new Gson();

    @Test
    public void testCollectingVulnerability() throws Exception {
        final JsonExtractor jsonExtractor = new JsonExtractor(gson);
        final BlackDuckProperties blackDuckProperties = BlackDuckCollectorTestHelper.mockProperties();

        final BlackDuckVulnerabilityCollector collector = new BlackDuckVulnerabilityCollector(jsonExtractor, messageContentProcessorList, blackDuckProperties);
        final NotificationContent notification = getNotificationContent(TestConstants.VULNERABILITY_NOTIFICATION_JSON_PATH);
        notification.setId(1L);
        collector.insert(notification);
        final List<MessageContentGroup> contentGroups = collector.collect(FormatType.DEFAULT);

        assertFalse(contentGroups.isEmpty());
        assertEquals(3, contentGroups.size());

        assertSingleComponentItemPerGroup(contentGroups);
        List<ComponentItem> componentItems = getComponentItems(getMessageContent(contentGroups));
        assertComponentItemContent(componentItems, "Custom Component", "1.0.0", UNKNOWN_VULNERABILITY);
    }

    @Test
    public void testCollectingVulnerabilityDigest() throws Exception {
        final JsonExtractor jsonExtractor = new JsonExtractor(gson);
        final BlackDuckProperties blackDuckProperties = BlackDuckCollectorTestHelper.mockProperties();

        final BlackDuckVulnerabilityCollector collector = new BlackDuckVulnerabilityCollector(jsonExtractor, messageContentProcessorList, blackDuckProperties);
        final NotificationContent notification = getNotificationContent(TestConstants.VULNERABILITY_NOTIFICATION_JSON_PATH);
        notification.setId(1L);
        collector.insert(notification);

        final List<MessageContentGroup> contentGroups = collector.collect(FormatType.DIGEST);
        assertFalse(contentGroups.isEmpty());

        final List<ProviderMessageContent> messageContents = getMessageContent(contentGroups);
        assertEquals(3, messageContents.size());
        Predicate<LinkableItem> removedVulnerabilityFilter = (item) -> item.getValue().equals("BDSA-2018-0004") || item.getValue().equals("CVE-2018-0010");
        for (MessageContentGroup group : contentGroups) {
            for (ProviderMessageContent providerContent : group.getSubContent()) {
                for (ComponentItem componentItem : providerContent.getComponentItems()) {
                    assertEquals("Custom Component", componentItem.getComponent().getValue());
                    assertEquals("1.0.0", componentItem.getSubComponent().map(LinkableItem::getValue).orElseThrow(() -> new IllegalStateException("Component Version missing")));
                    List<LinkableItem> removedVulnerabilities = componentItem.getComponentAttributes().stream().filter(removedVulnerabilityFilter).collect(Collectors.toList());
                    assertTrue(removedVulnerabilities.isEmpty());
                    final Optional<LinkableItem> severityItem = componentItem.getComponentAttributes().stream()
                                                                    .filter(linkableItem -> linkableItem.getName().equals(BlackDuckContent.LABEL_VULNERABILITY_SEVERITY))
                                                                    .findFirst();
                    assertTrue(severityItem.isPresent());
                    assertEquals(UNKNOWN_VULNERABILITY, severityItem.get().getValue());
                }
            }
        }
    }

    @Test
    public void testCollectingVulnerabilityWithConnection() throws Exception {
        final JsonExtractor jsonExtractor = new JsonExtractor(gson);
        final BlackDuckHttpClient blackDuckHttpClient = Mockito.mock(BlackDuckHttpClient.class);
        final BlackDuckServicesFactory hubServicesFactory = Mockito.mock(BlackDuckServicesFactory.class);
        final BlackDuckService hubService = Mockito.mock(BlackDuckService.class);
        final BlackDuckProperties blackDuckProperties = Mockito.mock(BlackDuckProperties.class);
        final BlackDuckBucketService bucketService = Mockito.mock(BlackDuckBucketService.class);

        final VulnerabilityView vulnerabilityView = new VulnerabilityView();
        vulnerabilityView.setName("vulnerability");
        vulnerabilityView.setSeverity(HIGH_VULNERABILITY);

        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_1), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_2), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_3), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_4), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_5), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_6), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_7), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_8), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_9), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_10), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_11), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_12), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_13), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_BDSA_4), Mockito.any())).thenReturn(vulnerabilityView);

        Mockito.when(hubServicesFactory.createBlackDuckService()).thenReturn(hubService);
        Mockito.when(hubServicesFactory.createBlackDuckBucketService()).thenReturn(bucketService);
        Mockito.when(blackDuckProperties.createBlackDuckHttpClientAndLogErrors(Mockito.any(Logger.class))).thenReturn(Optional.of(blackDuckHttpClient));
        Mockito.when(blackDuckProperties.createBlackDuckServicesFactory(Mockito.eq(blackDuckHttpClient), Mockito.any(Slf4jIntLogger.class))).thenReturn(hubServicesFactory);

        final BlackDuckVulnerabilityCollector collector = new BlackDuckVulnerabilityCollector(jsonExtractor, messageContentProcessorList, blackDuckProperties) {
            @Override
            public Optional<String> getProjectLink(final String projectVersionUrl, final String link) {
                return Optional.ofNullable(projectVersionUrl);
            }
        };

        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_1, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_2, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_3, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_4, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_5, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_6, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_7, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_8, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_9, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_10, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_11, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_12, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_13, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_BDSA_4, vulnerabilityView);

        final NotificationContent notification = getNotificationContent(TestConstants.VULNERABILITY_NOTIFICATION_JSON_PATH);
        notification.setId(1L);
        collector.insert(notification);
        final List<MessageContentGroup> contentGroups = collector.collect(FormatType.DEFAULT);

        assertFalse(contentGroups.isEmpty());
        assertEquals(3, contentGroups.size());

        assertSingleComponentItemPerGroup(contentGroups);
        List<ComponentItem> componentItems = getComponentItems(getMessageContent(contentGroups));
        assertComponentItemContent(componentItems, "Custom Component", "1.0.0", HIGH_VULNERABILITY);
    }

    @Test
    public void testCollectingVulnerabilityDigestWithConnection() throws Exception {
        final JsonExtractor jsonExtractor = new JsonExtractor(gson);
        final BlackDuckHttpClient blackDuckHttpClient = Mockito.mock(BlackDuckHttpClient.class);
        final BlackDuckServicesFactory hubServicesFactory = Mockito.mock(BlackDuckServicesFactory.class);
        final BlackDuckService hubService = Mockito.mock(BlackDuckService.class);
        final BlackDuckProperties blackDuckProperties = Mockito.mock(BlackDuckProperties.class);
        final BlackDuckBucketService bucketService = Mockito.mock(BlackDuckBucketService.class);

        final VulnerabilityView vulnerabilityView = new VulnerabilityView();
        vulnerabilityView.setName("vulnerability");
        vulnerabilityView.setSeverity(HIGH_VULNERABILITY);

        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_1), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_2), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_3), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_4), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_5), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_6), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_7), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_8), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_9), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_10), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_11), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_12), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_CVE_13), Mockito.any())).thenReturn(vulnerabilityView);
        Mockito.when(hubService.getResponse(Mockito.eq(VULNERABILITY_URL_BDSA_4), Mockito.any())).thenReturn(vulnerabilityView);

        Mockito.when(hubServicesFactory.createBlackDuckService()).thenReturn(hubService);
        Mockito.when(hubServicesFactory.createBlackDuckBucketService()).thenReturn(bucketService);
        Mockito.when(blackDuckProperties.createBlackDuckHttpClientAndLogErrors(Mockito.any(Logger.class))).thenReturn(Optional.of(blackDuckHttpClient));
        Mockito.when(blackDuckProperties.createBlackDuckServicesFactory(Mockito.eq(blackDuckHttpClient), Mockito.any(Slf4jIntLogger.class))).thenReturn(hubServicesFactory);

        final BlackDuckVulnerabilityCollector collector = new BlackDuckVulnerabilityCollector(jsonExtractor, messageContentProcessorList, blackDuckProperties) {
            @Override
            public Optional<String> getProjectLink(final String projectVersionUrl, final String link) {
                return Optional.ofNullable(projectVersionUrl);
            }
        };
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_1, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_2, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_3, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_4, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_5, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_6, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_7, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_8, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_9, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_10, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_11, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_12, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_CVE_13, vulnerabilityView);
        collector.getBlackDuckBucket().addValid(VULNERABILITY_URL_BDSA_4, vulnerabilityView);

        final NotificationContent notification = getNotificationContent(TestConstants.VULNERABILITY_NOTIFICATION_JSON_PATH);
        notification.setId(1L);
        collector.insert(notification);

        final List<MessageContentGroup> contentGroups = collector.collect(FormatType.DIGEST);
        final List<ProviderMessageContent> messageContents = getMessageContent(contentGroups);
        assertEquals(3, messageContents.size());
        Predicate<LinkableItem> removedVulnerabilityFilter = (item) -> item.getValue().equals("BDSA-2018-0004") || item.getValue().equals("CVE-2018-0010");
        for (MessageContentGroup group : contentGroups) {
            for (ProviderMessageContent providerContent : group.getSubContent()) {
                for (ComponentItem componentItem : providerContent.getComponentItems()) {
                    assertEquals("Custom Component", componentItem.getComponent().getValue());
                    assertEquals("1.0.0", componentItem.getSubComponent().map(LinkableItem::getValue).orElseThrow(() -> new IllegalStateException("Component Version missing")));
                    List<LinkableItem> removedVulnerabilities = componentItem.getComponentAttributes().stream().filter(removedVulnerabilityFilter).collect(Collectors.toList());
                    assertTrue(removedVulnerabilities.isEmpty());
                    final Optional<LinkableItem> severityItem = componentItem.getComponentAttributes().stream()
                                                                    .filter(linkableItem -> linkableItem.getName().equals(BlackDuckContent.LABEL_VULNERABILITY_SEVERITY))
                                                                    .findFirst();
                    assertTrue(severityItem.isPresent());
                    assertEquals(HIGH_VULNERABILITY, severityItem.get().getValue());
                }
            }
        }
    }

    @Test
    public void testCollectingVulnerabilityGetSeverityException() throws Exception {
        final JsonExtractor jsonExtractor = new JsonExtractor(gson);
        final BlackDuckHttpClient blackDuckHttpClient = BlackDuckCollectorTestHelper.mockHttpClient();
        final BlackDuckServicesFactory hubServicesFactory = BlackDuckCollectorTestHelper.mockServicesFactory();
        final BlackDuckService hubService = BlackDuckCollectorTestHelper.mockBlackDuckService();
        final BlackDuckProperties blackDuckProperties = BlackDuckCollectorTestHelper.mockProperties();

        final VulnerabilityView vulnerabilityView = new VulnerabilityView();
        vulnerabilityView.setName("vulnerability");
        vulnerabilityView.setSeverity(HIGH_VULNERABILITY);

        Mockito.when(hubService.getResponse(Mockito.anyString(), Mockito.any())).thenThrow(new IntegrationException("Test Integration Exception"));
        Mockito.when(hubServicesFactory.createBlackDuckService()).thenReturn(hubService);
        Mockito.when(blackDuckProperties.createBlackDuckHttpClientAndLogErrors(Mockito.any(Logger.class))).thenReturn(Optional.of(blackDuckHttpClient));
        Mockito.when(blackDuckProperties.createBlackDuckServicesFactory(Mockito.eq(blackDuckHttpClient), Mockito.any(Slf4jIntLogger.class))).thenReturn(hubServicesFactory);

        final BlackDuckVulnerabilityCollector collector = new BlackDuckVulnerabilityCollector(jsonExtractor, messageContentProcessorList, blackDuckProperties);
        final NotificationContent notification = getNotificationContent(TestConstants.VULNERABILITY_NOTIFICATION_JSON_PATH);
        notification.setId(1L);
        collector.insert(notification);
        final List<MessageContentGroup> contentGroups = collector.collect(FormatType.DEFAULT);

        assertFalse(contentGroups.isEmpty());
        assertEquals(3, contentGroups.size());

        assertSingleComponentItemPerGroup(contentGroups);
        List<ComponentItem> componentItems = getComponentItems(getMessageContent(contentGroups));
        assertComponentItemContent(componentItems, "Custom Component", "1.0.0", UNKNOWN_VULNERABILITY);
    }

    @Test
    public void testCollectingVulnerabilityOrdered() throws Exception {
        final JsonExtractor jsonExtractor = new JsonExtractor(gson);
        final BlackDuckHttpClient blackDuckHttpClient = Mockito.mock(BlackDuckHttpClient.class);
        final BlackDuckServicesFactory hubServicesFactory = Mockito.mock(BlackDuckServicesFactory.class);
        final BlackDuckService hubService = Mockito.mock(BlackDuckService.class);
        final BlackDuckProperties blackDuckProperties = Mockito.mock(BlackDuckProperties.class);
        final BlackDuckBucketService bucketService = Mockito.mock(BlackDuckBucketService.class);

        final VulnerabilityView highVulnerabilityView = new VulnerabilityView();
        highVulnerabilityView.setName("vulnerability");
        highVulnerabilityView.setSeverity(HIGH_VULNERABILITY);

        final VulnerabilityView mediumVulnerabilityView = new VulnerabilityView();
        mediumVulnerabilityView.setName("vulnerability");
        mediumVulnerabilityView.setSeverity(MEDIUM_VULNERABILITY);

        final VulnerabilityView lowVulnerabilityView = new VulnerabilityView();
        lowVulnerabilityView.setName("vulnerability");
        lowVulnerabilityView.setSeverity(LOW_VULNERABILITY);

        final Map<String, VulnerabilityView> urlToSeverityMap = new HashMap<>();
        urlToSeverityMap.put(VULNERABILITY_URL_CVE_1, lowVulnerabilityView);
        urlToSeverityMap.put(VULNERABILITY_URL_CVE_2, highVulnerabilityView);
        urlToSeverityMap.put(VULNERABILITY_URL_CVE_3, mediumVulnerabilityView);

        for (final Map.Entry<String, VulnerabilityView> entry : urlToSeverityMap.entrySet()) {
            Mockito.when(hubService.getResponse(Mockito.matches(entry.getKey()), Mockito.any())).thenReturn(entry.getValue());
        }

        Mockito.when(hubServicesFactory.createBlackDuckService()).thenReturn(hubService);
        Mockito.when(hubServicesFactory.createBlackDuckBucketService()).thenReturn(bucketService);
        Mockito.when(blackDuckProperties.createBlackDuckHttpClientAndLogErrors(Mockito.any(Logger.class))).thenReturn(Optional.of(blackDuckHttpClient));
        Mockito.when(blackDuckProperties.createBlackDuckServicesFactory(Mockito.eq(blackDuckHttpClient), Mockito.any(Slf4jIntLogger.class))).thenReturn(hubServicesFactory);

        final BlackDuckVulnerabilityCollector collector = new BlackDuckVulnerabilityCollector(jsonExtractor, messageContentProcessorList, blackDuckProperties) {
            @Override
            public Optional<String> getProjectLink(final String projectVersionUrl, final String link) {
                return Optional.ofNullable(projectVersionUrl);
            }
        };

        for (final Map.Entry<String, VulnerabilityView> entry : urlToSeverityMap.entrySet()) {
            collector.getBlackDuckBucket().addValid(entry.getKey(), entry.getValue());
        }

        final NotificationContent notification1 = getNotificationContent(TestConstants.VULNERABILITY_NOTIFICATION_SIMPLE_01_JSON_PATH);
        final NotificationContent notification2 = getNotificationContent(TestConstants.VULNERABILITY_NOTIFICATION_SIMPLE_02_JSON_PATH);
        notification1.setId(1L);
        notification1.setId(2L);
        collector.insert(notification1);
        collector.insert(notification2);
        final List<MessageContentGroup> messageContentGroups = collector.collect(FormatType.DEFAULT);
        //        System.out.println("# of messages: " + aggregateMessageContentList.size());
        for (final MessageContentGroup messageContentGroup : messageContentGroups) {
            for (final ProviderMessageContent providerMessageContent : messageContentGroup.getSubContent()) {
                //                System.out.println("KEY: " + aggregateMessageContent.getKey());
                System.out.println(providerMessageContent.getSubTopic());
                for (final ComponentItem componentItem : providerMessageContent.getComponentItems()) {
                    //                        System.out.println("   Category KEY: " + categoryItem.getCategoryKey());
                    //                        System.out.println("   Operation: " + categoryItem.getOperation());
                    LinkableItem vulnerabilityItem = componentItem.getComponentAttributes().stream()
                                                         .filter(linkableItem -> urlToSeverityMap.keySet().contains(linkableItem.getUrl().orElse(null)))
                                                         .findFirst().orElseThrow(() -> new IllegalStateException("Vulnerability item not found."));
                    String vulnerabilityUrl = vulnerabilityItem.getUrl().orElseThrow(() -> new IllegalStateException("Vulnerability URL missing"));
                    for (final LinkableItem item : componentItem.getComponentAttributes()) {
                        if (item.getName().equals(BlackDuckContent.LABEL_VULNERABILITY_SEVERITY)) {
                            assertTrue(urlToSeverityMap.containsKey(vulnerabilityUrl));
                            assertEquals(urlToSeverityMap.get(vulnerabilityUrl).getSeverity(), item.getValue());
                        }
                        //                                System.out.println("        Item name: " + item.getName());
                        //                                System.out.println("        Item value: " + item.getValue());
                    }
                    //                        System.out.println("");
                }
                //                System.out.println("");
                //                System.out.println("");
            }
        }
    }

    private void assertSingleComponentItemPerGroup(List<MessageContentGroup> contentGroups) {
        for (ProviderMessageContent content : getMessageContent(contentGroups)) {
            assertEquals(1, content.getComponentItems().size());
        }
    }

    private void assertComponentItemContent(List<ComponentItem> componentItems, String componentName, String componentVersion, String expectedSeverity) {
        for (ComponentItem item : componentItems) {
            assertEquals(14, item.getComponentAttributes().size());
            assertEquals(componentName, item.getComponent().getValue());
            assertEquals(componentVersion, item.getSubComponent().map(LinkableItem::getValue).orElseThrow(() -> new IllegalStateException("Component Version missing")));
            final Optional<LinkableItem> severityItem = item.getComponentAttributes().stream()
                                                            .filter(linkableItem -> linkableItem.getName().equals(BlackDuckContent.LABEL_VULNERABILITY_SEVERITY))
                                                            .findFirst();
            assertTrue(severityItem.isPresent());
            assertEquals(expectedSeverity, severityItem.get().getValue());
        }
    }

    private NotificationContent getNotificationContent(final String path) throws IOException {
        final ClassPathResource classPathResource = new ClassPathResource(path);
        final File jsonFile = classPathResource.getFile();
        final String notificationContent = FileUtils.readFileToString(jsonFile, Charset.defaultCharset());
        final Date creationDate = Date.from(Instant.now());
        return new NotificationContent(creationDate, BlackDuckProvider.COMPONENT_NAME, creationDate, NotificationType.VULNERABILITY.name(), notificationContent);
    }

    private List<ProviderMessageContent> getMessageContent(final List<MessageContentGroup> messageContentGroups) {
        return messageContentGroups
                   .stream()
                   .map(MessageContentGroup::getSubContent)
                   .flatMap(List::stream)
                   .collect(Collectors.toList());
    }

    private List<ComponentItem> getComponentItems(final List<ProviderMessageContent> providerMessageContents) {
        return providerMessageContents
                   .stream()
                   .map(ProviderMessageContent::getComponentItems)
                   .flatMap(Collection::stream)
                   .collect(Collectors.toList());
    }

}
